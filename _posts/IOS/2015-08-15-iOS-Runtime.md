---
layout: post
title: Objective-C Runtime
category: iOS
tags: iOS
keywords: runtime
description:
---

众所周知，Objective-C 是一门动态语言。很多东西都是在运行时决定的，而不是在编译或者链接时决定的。这就要求这门语言不仅仅需要一个编译器还需要一个运行时系统来执行编译后的代码。 

### 版本 ###

现在有新（modern）旧（legacy）两个版本的runtime系统在运行。新版本包括 Objective-C 2.0 和一些新特性。旧版本包括 Objective-C 1.0。
新旧两个版本之间的最大的不同就在于，当你改变某一个类中的实例变量时，旧版本需要重新编译这个类的所有子类，而新版本就就不用了。

### 和 Runtime 系统交互 ###

Objective-C 程序和 Runtime 系统之间的交互有三种方式：通过 Objective-C 源码，通过Foundation框架中的NSObject类中的方法，直接调用运行时系统函数

* 通过 Objective-C 源码：

	在多数情况下，runtime 系统在这个层次下自动工作。当编译 Objective-C 应用程序的时候，编译器会创建相关语言特性的数据结构和函数调用。创建的数据结构会捕获类或者协议中的一些东西，比如 Selector, 实例变量等等。这些都会通过源码来调用。  

* 队列的优先级  

	在 Cocoa 中绝大多数类都是 NSObject 的子类，也就是说它定义了继承自它的子类的一些行为。在少数情况下 NSObject 只是提供了一些抽象的接口，而不是所有的代码都由自己来实现。比如 `description` 方法。NSObject 在实现这个方法的时候，由于不知道具体类里都包含什么东西，所以它只是返回一个类名和类实例地址的一个字符串。NSObject 的子类可以返回更多的信息。比如 NSArray 返回了它所包含的所有对象。  
	一些 NSObject 方法可向runtime系统查询一下简单的信息。例如 `class` 方法，它可以告诉你这个实例是哪个类的实例，`isKindOfClass` 可以判断当前实例是否属于这个类以及这个类的子类，还有 `isMenberOfClass` 可以判断当前实例是否属于这个类等等。

* 通过调用 runtime 系统方法。

	运行时系统是一个包含一系列数据结构和方法（位于 /usr/include/objc 目录下）的动态库。其中很多方法可以实现编译 Objective-C 程序时编译器做的事情。还有一些方法属于 NSObject 类的一些基础方法，这些方法提供了 runtime 系统的其他一些接口，一般你用不到它们，除非你在开发一些偏低层的东西。


### 消息 ###

#### objc_msgSend 方法 ####

在 Objective-C 中消息是在运行时才绑定到方法的实现的。编译器通过 objc-msgSend 方法来绑定一个消息的实现.例如 `[receiver message]` 转化成 `objc_msgSend(receiver, message)`,如果消息带参数则转化成 `objc_msgSend`(receiver, message, arg1, arg2, ...)`.
这个方法会做动态绑定相关的一切事情。

1. 首先它会根据发送消息的对象来找这个方法的实现。
2. 它会调用这个方法的实现，并把需要的参数传递进去。
3. 最后他把函数的返回值以自己的返回值返回。
	
备注：编译器会自动生成调用消息方法的函数，任何时候你都不应该自己去实现它。  

编译器为每个类和实例都生成了一些数据结构体。每个结构体都包含以下两个必不可少的元素。  
* 指向父类的指针
* 类分发表。这个表中把类中的每个方法以及方法实现的地址关联了起来。

当产生一个新类的时候，系统会给它申请相关的内存，并且初始化它的实例变量。首先这个类的实例变量是一个指针，指向它对应的类的结构体，这个指针叫做 `isa` 指针。这个指针将对象关联到相关的类中，并且通过指针将对象关联到相关的类中，并且通过这个类来关联到所有继承自它的子类中。

备注：严格的来说，`isa` 指针不是这个语言的一部分，但他又是 Objective-C runtime 系统所必不可少的。一个对象和一个 `objc_object` 的结构体是等同的。一般情况下我们不会自己创造基类。继承自 NSObject 和 NSProxy 的类会自动有这个 `isa` 指针变量。

下图是对象结构体的示意图

![messaging](/public/img/messaging.gif) 

当一个对象接收到一个消息时，会在该对象的 `isa` 指针指向的类结构体的分发表中寻找消息对应的方法。如果找不到就会去父类中的分发表中寻找，一直找到 NSObject 类为止。如果找到了，objc_msgSend 方法会把对应的方法的实现的地址传递给接收消息的类的结构体。以上就是 runtime 系统定位消息的过程，也就是说消息被动态绑定到这个方法上了。  

为了加快消息的定位过程，runtime 系统会缓存选择器和他们所对应的方法的实现的地址。每个类会被分别缓存，它包含继承的方法和自己定义的方法。在搜索分发表之前，会首先检查接收消息对象的类的缓存，如果缓存中找到了对应的方法以及方法实现的地址。那么就会直接调用方法。随着程序的运行，每个类的缓存也会逐渐增加。以至于运行很长时间之后几乎每个消息都可以在缓存中找到对应的方法。  

#### 使用隐藏的参数 ####

在 objc_msgSend 方法把找到的消息对应的方法发送给消息接收者的时候，它同时还会传递两个隐藏的参数，接收消息的对象，方法对应的Selector。虽然这两个参数没有在定义中声明，但是它们是在编译时插入到执行代码当中的，在源码中同样可以引用他们。指向消息接收对象的是 `self`,指向方法选择器的是 `_cmd`.具体参看下面的代码。



#### 获取一个方法的地址 ####



参考文章  [test](http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/)
